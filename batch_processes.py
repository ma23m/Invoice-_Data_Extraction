# -*- coding: utf-8 -*-
"""invoice_relevant_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H0kwORyU99NlvT5EqkTKUHTlp-m4zOjU
"""

!pip install pdfplumber

!pip install pytesseract

!pip install pdf2image

"""**Scalability and Efficiency:**

**○ The solution should be scalable to handle large volumes of invoices.**

**○ Optimize for processing speed without compromising accuracy.**

**Error Handling and Reporting:**

**○ Implement robust error handling mechanisms**

**○ Provide clear reports on extraction failures, accuracy issues, and data reliability.**
"""

import os
import re
import pdfplumber
import pytesseract
from pdf2image import convert_from_path
import pandas as pd
import concurrent.futures
import logging
import time

# Configure logging
logging.basicConfig(filename='error_log.txt', level=logging.DEBUG)

# Helper function to split list into batches
def batchify(data, batch_size):
    """Split the data into batches of a given size."""
    for i in range(0, len(data), batch_size):
        yield data[i:i + batch_size]

def extract_text_from_pdf(pdf_path):
    try:
        text = ""
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ""
        if not text.strip():
            images = convert_from_path(pdf_path)
            for image in images:
                text += pytesseract.image_to_string(image)
        return text
    except Exception as e:
        logging.error(f"Error processing {pdf_path}: {e}")
        return ""  # Return empty string if an error occurs

def extract_invoice_data(text, filename):
    """Extract invoice data from text."""
    data = {}

    try:
        # Example regex patterns; adjust as needed
        patterns = {
            'Invoice Number': r'Invoice #:\s*(\S+)',
            'Invoice Date': r'Invoice Date:\s*(\d{2} \w+ \d{4})',
            'Due Date': r'Due Date:\s*(\d{2} \w+ \d{4})',
            'Item Details': r'# Item\s+(.*?)\n',
            'Taxable Amount': r'Taxable Amount ₹([\d,]+)',
            'CGST': r'CGST 9.0% ₹([\d,]+)',
            'SGST': r'SGST 9.0% ₹([\d,]+)',
        }

        for key, pattern in patterns.items():
            match = re.search(pattern, text)
            data[key] = match.group(1) if match else None

        # Calculate Total Amount
        data['Total Amount'] = (
            float(data['Taxable Amount'].replace(',', '')) if data['Taxable Amount'] else 0 +
            float(data['CGST'].replace(',', '')) if data['CGST'] else 0 +
            float(data['SGST'].replace(',', '')) if data['SGST'] else 0
        )

        # Extract customer name from the filename
        customer_name = filename.split('_')[1].replace('.pdf', '') if '_' in filename else None
        data['Customer Name'] = customer_name

    except Exception as e:
        logging.error(f"Error extracting data from {filename}: {e}")
        data = {'Invoice Number': None, 'Invoice Date': None, 'Due Date': None, 'Total Amount': None, 'Customer Name': None}

    return data

def validate_data(data, total_counts, correct_counts):
    """Validate extracted data and update accuracy counts."""
    accuracy_checks = {
        'Invoice Number': data['Invoice Number'] is not None and isinstance(data['Invoice Number'], str),
        'Invoice Date': bool(re.match(r'\d{2} \w+ \d{4}', data['Invoice Date'])) if data['Invoice Date'] else False,
        'Due Date': bool(re.match(r'\d{2} \w+ \d{4}', data['Due Date'])) if data['Due Date'] else False,
        'Total Amount': isinstance(data['Total Amount'], (int, float)) and data['Total Amount'] >= 0,
    }

    # Update total and correct counts
    for field, is_correct in accuracy_checks.items():
        total_counts[field] += 1
        if is_correct:
            correct_counts[field] += 1

    # Determine trust level
    trust_level = 'Trusted' if all(accuracy_checks.values()) else 'Not Trusted'

    return accuracy_checks, trust_level

def process_pdf(pdf_path):
    """Process a single PDF file."""
    extracted_text = extract_text_from_pdf(pdf_path)
    invoice_data = extract_invoice_data(extracted_text, os.path.basename(pdf_path))
    return invoice_data

def generate_report(total_counts, correct_counts, extracted_data):
    """Generate a report of the extraction process."""
    failed_extractions = [data for data in extracted_data if data.get('Trust Level') == 'Not Trusted']
    report_data = {
        'Total Invoices Processed': len(extracted_data),
        'Failed Extractions': len(failed_extractions),
        'Accuracy': {field: (correct_counts[field] / total_counts[field]) * 100 if total_counts[field] > 0 else 0
                     for field in total_counts}
    }

    report_df = pd.DataFrame(report_data, index=[0])
    report_df.to_excel('extraction_report.xlsx', index=False)

def process_batch(batch_pdf_paths, batch_index, total_counts, correct_counts):
    """Process a batch of PDFs and extract data."""
    extracted_data = []

    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_pdf = {executor.submit(process_pdf, pdf_path): pdf_path for pdf_path in batch_pdf_paths}

        for future in concurrent.futures.as_completed(future_to_pdf):
            pdf_path = future_to_pdf[future]
            try:
                invoice_data = future.result()
                extracted_data.append(invoice_data)
            except Exception as e:
                logging.error(f"Error processing {pdf_path}: {e}")

    # Validate data and accumulate accuracy counts
    for invoice_data in extracted_data:
        accuracy_checks, trust_level = validate_data(invoice_data, total_counts, correct_counts)
        invoice_data['Accuracy Checks'] = accuracy_checks
        invoice_data['Trust Level'] = trust_level

    # Save the batch data incrementally
    batch_df = pd.DataFrame(extracted_data)
    batch_df.to_excel(f'batch_{batch_index}_data.xlsx', index=False)

def main():
    pdf_folder = '/content/Invoice'  # Define the folder containing PDF invoices
    batch_size = 4  # Define the size of each batch

    total_counts = {
        'Invoice Number': 0,
        'Invoice Date': 0,
        'Due Date': 0,
        'Total Amount': 0
    }

    correct_counts = {
        'Invoice Number': 0,
        'Invoice Date': 0,
        'Due Date': 0,
        'Total Amount': 0
    }

    # List all PDF files in the folder
    pdf_paths = [os.path.join(pdf_folder, filename) for filename in os.listdir(pdf_folder) if filename.endswith('.pdf')]

    # Split the PDFs into batches
    pdf_batches = list(batchify(pdf_paths, batch_size))

    # Process each batch separately
    for batch_index, batch_pdf_paths in enumerate(pdf_batches, start=1):
        print(f"Processing batch {batch_index}/{len(pdf_batches)}...")
        process_batch(batch_pdf_paths, batch_index, total_counts, correct_counts)

    # Calculate overall accuracy and generate final report
    overall_accuracy = {field: (correct_counts[field] / total_counts[field]) * 100 if total_counts[field] > 0 else 0 for field in total_counts}
    print(f"Overall Accuracy Rates: {overall_accuracy}")

    # Final report after all batches are processed
    generate_report(total_counts, correct_counts, [])

if __name__ == "__main__":
    main()