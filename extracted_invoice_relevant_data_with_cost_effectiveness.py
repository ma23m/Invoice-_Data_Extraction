# -*- coding: utf-8 -*-
"""invoice_relevant_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H0kwORyU99NlvT5EqkTKUHTlp-m4zOjU
"""

!pip install pdfplumber

!pip install pytesseract

!pip install pdf2image

"""**Cost-Effectiveness vs. Accuracy:**
**○ Analyze and implement the most cost-effective approach while prioritizing accuracy.**

**○ If an approach is 20% more expensive but provides a 5% increase in accuracy,prefer the more accurate approach.**

**Performance Metrics:**

**○ Achieve an overall accuracy rate of >90%.**

**○ Provide a detailed breakdown of accuracy rates for different types of invoice data(e.g., invoice number, date, total amount, line items).**
"""

import os
import re
import pdfplumber
import pytesseract
from pdf2image import convert_from_path
import pandas as pd

# Function to simulate accuracy and cost for two methods
def simulate_methods():
    method_1 = {
        'name': 'Method 1',
        'cost': 100,  # Example cost for method 1
        'accuracy': 0.90  # Example accuracy for method 1 (90%)
    }

    method_2 = {
        'name': 'Method 2',
        'cost': 120,  # 20% more expensive than method 1
        'accuracy': 0.95  # 5% more accurate than method 1 (95%)
    }

    return method_1, method_2

# Function to determine the preferred method based on cost and accuracy
def determine_best_method(method_1, method_2):
    print(f"Method 1: Cost = {method_1['cost']}, Accuracy = {method_1['accuracy']}")
    print(f"Method 2: Cost = {method_2['cost']}, Accuracy = {method_2['accuracy']}")

    # Check if Method 2 is within the cost limit
    cost_limit = method_1['cost'] * 1.2
    is_cost_effective = method_2['cost'] <= cost_limit
    print(f"Method 2 is within the cost limit: {is_cost_effective}")

    # Check if Method 2 meets the accuracy improvement requirement
    accuracy_improvement_threshold = method_1['accuracy'] + 0.05
    print(f"Expected accuracy improvement threshold: {accuracy_improvement_threshold}")

    # Use a tolerance for the comparison
    accuracy_improvement = method_2['accuracy'] >= accuracy_improvement_threshold - 1e-9  # Tolerance
    print(f"Comparing: Method 2 Accuracy ({method_2['accuracy']}) >= Method 1 Accuracy ({method_1['accuracy']}) + 0.05")
    print(f"Accuracy improvement check: {accuracy_improvement}")

    # Decision-making logic
    if is_cost_effective and accuracy_improvement:
        print("Choosing Method 2")
        return method_2  # Prefer method 2

    print("Choosing Method 1")
    return method_1  # Prefer method 1

# Function to extract specific fields using regex patterns
def extract_invoice_data(text, filename):
    data = {}

    # Extract Invoice Number
    invoice_number = re.search(r'Invoice #:\s*(\S+)', text)
    data['Invoice Number'] = invoice_number.group(1) if invoice_number else None

    # Extract Invoice Date
    invoice_date = re.search(r'Invoice Date:\s*(\d{2} \w+ \d{4})', text)
    data['Invoice Date'] = invoice_date.group(1) if invoice_date else None

    # Extract Due Date
    due_date = re.search(r'Due Date:\s*(\d{2} \w+ \d{4})', text)
    data['Due Date'] = due_date.group(1) if due_date else None

    # Extract Item details (First line of item description)
    item_details = re.search(r'# Item\s+(.*?)\n', text)
    data['Item Details'] = item_details.group(1).strip() if item_details else None

    # Extract Taxable Amount, CGST, SGST, and Total Amount
    taxable_amount = re.search(r'Taxable Amount ₹([\d,]+)', text)
    cgst = re.search(r'CGST 9.0% ₹([\d,]+)', text)
    sgst = re.search(r'SGST 9.0% ₹([\d,]+)', text)

    # Calculate total amount
    total_amount = 0
    if taxable_amount:
        total_amount += float(taxable_amount.group(1).replace(',', ''))

    if cgst:
        total_amount += float(cgst.group(1).replace(',', ''))
    else:
        data['CGST'] = 0.0

    if sgst:
        total_amount += float(sgst.group(1).replace(',', ''))
    else:
        data['SGST'] = 0.0

    # Store calculated total amount
    data['Total Amount'] = total_amount

    # Extract customer name from the filename
    customer_name = filename.split('_')[1].replace('.pdf', '') if '_' in filename else None
    data['Customer Name'] = customer_name

    return data

# Function to validate extracted data and calculate accuracy rates
def validate_data(data, total_counts, correct_counts):
    accuracy_checks = {
        'Invoice Number': data['Invoice Number'] is not None and isinstance(data['Invoice Number'], str),
        'Invoice Date': bool(re.match(r'\d{2} \w+ \d{4}', data['Invoice Date'])) if data['Invoice Date'] else False,
        'Due Date': bool(re.match(r'\d{2} \w+ \d{4}', data['Due Date'])) if data['Due Date'] else False,
        'Total Amount': isinstance(data['Total Amount'], (int, float)) and data['Total Amount'] >= 0,
    }

    # Update total and correct counts
    for field, is_correct in accuracy_checks.items():
        total_counts[field] += 1
        if is_correct:
            correct_counts[field] += 1

    # Determine trust level
    trust_level = 'Trusted' if all(accuracy_checks.values()) else 'Not Trusted'

    return accuracy_checks, trust_level

# Main function
def main():
    pdf_folder = '/content/Invoice'
    extracted_data = []

    # Initialize counts for accuracy calculations
    total_counts = {
        'Invoice Number': 0,
        'Invoice Date': 0,
        'Due Date': 0,
        'Total Amount': 0
    }

    correct_counts = {
        'Invoice Number': 0,
        'Invoice Date': 0,
        'Due Date': 0,
        'Total Amount': 0
    }

    # Simulate methods and determine best method
    method_1, method_2 = simulate_methods()
    best_method = determine_best_method(method_1, method_2)

    # Process each PDF
    for filename in os.listdir(pdf_folder):
        if filename.endswith('.pdf'):
            pdf_path = os.path.join(pdf_folder, filename)
            extracted_text = extract_text_from_pdf(pdf_path)

            # Extract structured data from the text
            invoice_data = extract_invoice_data(extracted_text, filename)

            # Validate data and get accuracy checks
            accuracy_checks, trust_level = validate_data(invoice_data, total_counts, correct_counts)
            invoice_data['Accuracy Checks'] = accuracy_checks
            invoice_data['Trust Level'] = trust_level
            invoice_data['Best Method'] = best_method['name']

            extracted_data.append(invoice_data)


    overall_accuracy = {field: (correct_counts[field] / total_counts[field]) * 100 if total_counts[field] > 0 else 0
                        for field in total_counts}


    print(f"Overall Accuracy Rates: {overall_accuracy}")
    df = pd.DataFrame(extracted_data)
    df = df[['Invoice Number', 'Invoice Date', 'Due Date', 'Customer Name', 'Total Amount', 'Trust Level', 'Best Method']]
    df['Invoice Number'] = pd.to_numeric(df['Invoice Number'].str.replace(r'\D', '', regex=True), errors='coerce')
    df = df.sort_values(by='Invoice Number')
    output_excel_path = 'extracted_invoice_relevant_data_with_cost_effectiveness.xlsx'
    df.to_excel(output_excel_path, index=False)

    print(f"Data has been successfully saved to {output_excel_path}")

if __name__ == "__main__":
    main()